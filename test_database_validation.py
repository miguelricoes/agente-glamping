#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Test REAL de Validaci√≥n de Base de Datos - Glamping Brillo de Luna
Pruebas exhaustivas de conectividad y operaciones de base de datos
"""

import os
import sys
import uuid
import json
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configurar encoding
if hasattr(sys.stdout, 'reconfigure'):
    sys.stdout.reconfigure(encoding='utf-8', errors='ignore')

# Cargar variables de entorno
load_dotenv()

print("üóÑÔ∏è TEST REAL DE VALIDACI√ìN DE BASE DE DATOS")
print("üéØ Validaci√≥n exhaustiva de conectividad y operaciones")
print("=" * 70)

class DatabaseValidationTest:
    """Pruebas reales de base de datos para el agente"""
    
    def __init__(self):
        self.test_results = {
            "connection_test": False,
            "model_validation": False,
            "crud_operations": False,
            "availability_queries": False,
            "reservation_flow": False,
            "data_persistence": False,
            "transaction_integrity": False
        }
        
        self.db_config = None
        self.test_user_id = f"db_test_{str(uuid.uuid4())[:8]}"
        
        print(f"üë§ Test User ID: {self.test_user_id}")
        
    def test_database_connection(self):
        """Probar conexi√≥n real a la base de datos"""
        print("\nüîå PRUEBA 1: CONEXI√ìN A BASE DE DATOS")
        print("-" * 50)
        
        try:
            # Verificar variables de entorno
            db_url = os.getenv('DATABASE_URL')
            if not db_url:
                print("‚ùå DATABASE_URL no configurada")
                return False
            
            print(f"‚úÖ DATABASE_URL encontrada: {db_url[:30]}...")
            
            # Intentar importar y conectar
            from config.database_config import DatabaseConfig
            from flask import Flask
            
            # Crear app temporal para contexto
            app = Flask(__name__)
            app.config['SQLALCHEMY_DATABASE_URI'] = db_url
            app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
            
            with app.app_context():
                self.db_config = DatabaseConfig()
                success = self.db_config.init_app(app)
                
                if success and self.db_config.database_available:
                    # Probar consulta b√°sica
                    from sqlalchemy import text
                    result = self.db_config.db.session.execute(text('SELECT 1')).fetchone()
                    
                    if result:
                        print("‚úÖ Conexi√≥n a base de datos exitosa")
                        print("‚úÖ Consulta de prueba ejecutada correctamente")
                        self.test_results["connection_test"] = True
                        return True
                    else:
                        print("‚ùå Error en consulta de prueba")
                        return False
                else:
                    print("‚ùå No se pudo inicializar la conexi√≥n")
                    return False
                    
        except Exception as e:
            print(f"‚ùå Error de conexi√≥n: {e}")
            return False
    
    def test_model_validation(self):
        """Validar que los modelos de BD est√°n correctamente definidos"""
        print("\nüìã PRUEBA 2: VALIDACI√ìN DE MODELOS")
        print("-" * 50)
        
        if not self.db_config:
            print("‚ùå No hay conexi√≥n de BD disponible")
            return False
        
        try:
            # Verificar modelos requeridos
            required_models = ['Usuario', 'Reserva']
            models_found = []
            
            for model_name in required_models:
                if hasattr(self.db_config, model_name):
                    model = getattr(self.db_config, model_name)
                    print(f"‚úÖ Modelo {model_name}: Encontrado")
                    models_found.append(model_name)
                    
                    # Verificar que el modelo tiene tabla
                    if hasattr(model, '__tablename__'):
                        print(f"   üìÑ Tabla: {model.__tablename__}")
                    
                    # Verificar columnas b√°sicas
                    if hasattr(model, '__table__'):
                        columns = [col.name for col in model.__table__.columns]
                        print(f"   üìù Columnas: {len(columns)} encontradas")
                else:
                    print(f"‚ùå Modelo {model_name}: NO encontrado")
            
            success = len(models_found) >= 2
            self.test_results["model_validation"] = success
            
            if success:
                print("‚úÖ Modelos de BD validados correctamente")
            else:
                print("‚ùå Faltan modelos cr√≠ticos de BD")
            
            return success
            
        except Exception as e:
            print(f"‚ùå Error validando modelos: {e}")
            return False
    
    def test_crud_operations(self):
        """Probar operaciones CRUD b√°sicas"""
        print("\nüîÑ PRUEBA 3: OPERACIONES CRUD")
        print("-" * 50)
        
        if not self.db_config or not self.test_results["model_validation"]:
            print("‚ùå Prerrequisitos no cumplidos")
            return False
        
        try:
            with self.db_config.db.session.begin():
                # CREATE - Crear usuario de prueba
                Usuario = self.db_config.Usuario
                test_user = Usuario(
                    id=self.test_user_id,
                    nombre="Test Usuario",
                    telefono="+57300123456",
                    email="test@glamping.com"
                )
                
                self.db_config.db.session.add(test_user)
                self.db_config.db.session.flush()  # Para obtener ID
                print("‚úÖ CREATE: Usuario de prueba creado")
                
                # READ - Leer usuario
                found_user = Usuario.query.filter_by(id=self.test_user_id).first()
                if found_user and found_user.nombre == "Test Usuario":
                    print("‚úÖ READ: Usuario le√≠do correctamente")
                else:
                    print("‚ùå READ: Error leyendo usuario")
                    return False
                
                # UPDATE - Actualizar usuario
                found_user.email = "updated@glamping.com"
                self.db_config.db.session.flush()
                
                updated_user = Usuario.query.filter_by(id=self.test_user_id).first()
                if updated_user.email == "updated@glamping.com":
                    print("‚úÖ UPDATE: Usuario actualizado correctamente")
                else:
                    print("‚ùå UPDATE: Error actualizando usuario")
                    return False
                
                # DELETE se har√° al final del test
                print("‚úÖ Operaciones CRUD b√°sicas funcionando")
                self.test_results["crud_operations"] = True
                return True
                
        except Exception as e:
            print(f"‚ùå Error en operaciones CRUD: {e}")
            return False
    
    def test_availability_queries(self):
        """Probar consultas de disponibilidad"""
        print("\nüìÖ PRUEBA 4: CONSULTAS DE DISPONIBILIDAD")
        print("-" * 50)
        
        if not self.db_config:
            print("‚ùå No hay conexi√≥n de BD")
            return False
        
        try:
            # Importar servicio de disponibilidad
            from services.availability_service import AvailabilityService
            
            availability_service = AvailabilityService(
                self.db_config.db,
                self.db_config.Reserva
            )
            
            # Probar consulta de disponibilidad
            fecha_inicio = datetime.now().date() + timedelta(days=7)
            fecha_fin = fecha_inicio + timedelta(days=2)
            
            # Verificar que el m√©todo existe y funciona
            if hasattr(availability_service, 'check_availability'):
                disponibilidad = availability_service.check_availability(
                    fecha_inicio, fecha_fin, 2
                )
                print("‚úÖ Consulta de disponibilidad ejecutada")
                print(f"   üìä Resultado: {type(disponibilidad)}")
            else:
                print("‚ö†Ô∏è M√©todo check_availability no encontrado")
            
            # Probar otros m√©todos comunes
            methods_to_test = [
                'get_available_domos',
                'check_domo_availability',
                'get_reservations_by_date'
            ]
            
            working_methods = 0
            for method in methods_to_test:
                if hasattr(availability_service, method):
                    print(f"‚úÖ M√©todo {method}: Disponible")
                    working_methods += 1
                else:
                    print(f"‚ö†Ô∏è M√©todo {method}: No encontrado")
            
            success = working_methods >= 1
            self.test_results["availability_queries"] = success
            
            if success:
                print("‚úÖ Sistema de disponibilidad operativo")
            else:
                print("‚ùå Sistema de disponibilidad no funcional")
            
            return success
            
        except Exception as e:
            print(f"‚ùå Error en consultas de disponibilidad: {e}")
            return False
    
    def test_reservation_flow(self):
        """Probar flujo completo de reserva"""
        print("\nüìù PRUEBA 5: FLUJO DE RESERVA COMPLETO")
        print("-" * 50)
        
        if not self.db_config:
            print("‚ùå No hay conexi√≥n de BD")
            return False
        
        try:
            # Importar servicio de reservas
            from services.reservation_service import ReservationService
            
            reservation_service = ReservationService(
                self.db_config.db,
                self.db_config.Reserva
            )
            
            # Datos de prueba para reserva
            reserva_data = {
                "usuario_id": self.test_user_id,
                "domo_tipo": "Antares",
                "fecha_inicio": (datetime.now() + timedelta(days=30)).date(),
                "fecha_fin": (datetime.now() + timedelta(days=32)).date(),
                "num_personas": 2,
                "precio_total": 420000,
                "telefono": "+57300123456"
            }
            
            # Probar creaci√≥n de reserva
            if hasattr(reservation_service, 'create_reservation'):
                reserva = reservation_service.create_reservation(reserva_data)
                if reserva:
                    print("‚úÖ Reserva creada exitosamente")
                    print(f"   üìã ID: {getattr(reserva, 'id', 'N/A')}")
                else:
                    print("‚ùå Error creando reserva")
                    return False
            else:
                print("‚ö†Ô∏è M√©todo create_reservation no encontrado")
                # Intentar crear reserva directamente
                try:
                    Reserva = self.db_config.Reserva
                    nueva_reserva = Reserva(**reserva_data)
                    self.db_config.db.session.add(nueva_reserva)
                    self.db_config.db.session.commit()
                    print("‚úÖ Reserva creada directamente")
                except Exception as e:
                    print(f"‚ùå Error creando reserva directa: {e}")
                    return False
            
            # Verificar que la reserva se guard√≥
            Reserva = self.db_config.Reserva
            reserva_guardada = Reserva.query.filter_by(usuario_id=self.test_user_id).first()
            
            if reserva_guardada:
                print("‚úÖ Reserva verificada en base de datos")
                print(f"   üè† Domo: {getattr(reserva_guardada, 'domo_tipo', 'N/A')}")
                print(f"   üí∞ Precio: ${getattr(reserva_guardada, 'precio_total', 'N/A')}")
            else:
                print("‚ùå Reserva no encontrada en BD")
                return False
            
            self.test_results["reservation_flow"] = True
            return True
            
        except Exception as e:
            print(f"‚ùå Error en flujo de reserva: {e}")
            return False
    
    def test_data_persistence(self):
        """Probar persistencia de datos"""
        print("\nüíæ PRUEBA 6: PERSISTENCIA DE DATOS")
        print("-" * 50)
        
        if not self.db_config:
            print("‚ùå No hay conexi√≥n de BD")
            return False
        
        try:
            # Verificar que los datos creados en tests anteriores persisten
            Usuario = self.db_config.Usuario
            Reserva = self.db_config.Reserva
            
            # Verificar usuario
            user = Usuario.query.filter_by(id=self.test_user_id).first()
            if user:
                print("‚úÖ Usuario persiste en BD")
                print(f"   üë§ Nombre: {user.nombre}")
                print(f"   üìß Email: {user.email}")
            else:
                print("‚ùå Usuario no persiste")
                return False
            
            # Verificar reserva
            reserva = Reserva.query.filter_by(usuario_id=self.test_user_id).first()
            if reserva:
                print("‚úÖ Reserva persiste en BD")
                print(f"   üè† Domo: {getattr(reserva, 'domo_tipo', 'N/A')}")
                print(f"   üìÖ Fecha: {getattr(reserva, 'fecha_inicio', 'N/A')}")
            else:
                print("‚ùå Reserva no persiste")
                return False
            
            # Probar consulta con relaciones (si existen)
            try:
                if hasattr(user, 'reservas'):
                    reservas_usuario = user.reservas
                    print(f"‚úÖ Relaciones funcionando: {len(reservas_usuario)} reservas")
                else:
                    print("‚ö†Ô∏è Relaciones entre modelos no configuradas")
            except Exception as rel_error:
                print(f"‚ö†Ô∏è Error en relaciones: {rel_error}")
            
            self.test_results["data_persistence"] = True
            return True
            
        except Exception as e:
            print(f"‚ùå Error verificando persistencia: {e}")
            return False
    
    def test_transaction_integrity(self):
        """Probar integridad de transacciones"""
        print("\nüîê PRUEBA 7: INTEGRIDAD DE TRANSACCIONES")
        print("-" * 50)
        
        if not self.db_config:
            print("‚ùå No hay conexi√≥n de BD")
            return False
        
        try:
            # Probar rollback en caso de error
            Usuario = self.db_config.Usuario
            
            try:
                with self.db_config.db.session.begin():
                    # Crear usuario temporal
                    temp_user = Usuario(
                        id="temp_rollback_test",
                        nombre="Temp User",
                        telefono="+57300999999",
                        email="temp@test.com"
                    )
                    self.db_config.db.session.add(temp_user)
                    self.db_config.db.session.flush()
                    
                    # Verificar que se cre√≥ temporalmente
                    found = Usuario.query.filter_by(id="temp_rollback_test").first()
                    if found:
                        print("‚úÖ Usuario temporal creado en transacci√≥n")
                    
                    # Forzar error para probar rollback
                    raise Exception("Test rollback")
                    
            except Exception as e:
                if "Test rollback" in str(e):
                    # Verificar que el rollback funcion√≥
                    rolled_back_user = Usuario.query.filter_by(id="temp_rollback_test").first()
                    if not rolled_back_user:
                        print("‚úÖ Rollback funcion√≥ correctamente")
                    else:
                        print("‚ùå Rollback no funcion√≥")
                        return False
                else:
                    print(f"‚ùå Error inesperado: {e}")
                    return False
            
            # Probar commit exitoso
            with self.db_config.db.session.begin():
                commit_user = Usuario(
                    id="commit_test_user",
                    nombre="Commit Test",
                    telefono="+57300888888",
                    email="commit@test.com"
                )
                self.db_config.db.session.add(commit_user)
                # Transacci√≥n se commitea autom√°ticamente al salir del with
            
            # Verificar que el commit funcion√≥
            committed_user = Usuario.query.filter_by(id="commit_test_user").first()
            if committed_user:
                print("‚úÖ Commit exitoso verificado")
                
                # Limpiar usuario de prueba
                self.db_config.db.session.delete(committed_user)
                self.db_config.db.session.commit()
            else:
                print("‚ùå Commit no funcion√≥")
                return False
            
            self.test_results["transaction_integrity"] = True
            return True
            
        except Exception as e:
            print(f"‚ùå Error en integridad de transacciones: {e}")
            return False
    
    def cleanup_test_data(self):
        """Limpiar datos de prueba"""
        print("\nüßπ LIMPIEZA DE DATOS DE PRUEBA")
        print("-" * 50)
        
        if not self.db_config:
            return
        
        try:
            # Eliminar reservas de prueba
            Reserva = self.db_config.Reserva
            reservas_test = Reserva.query.filter_by(usuario_id=self.test_user_id).all()
            for reserva in reservas_test:
                self.db_config.db.session.delete(reserva)
            print(f"‚úÖ {len(reservas_test)} reservas de prueba eliminadas")
            
            # Eliminar usuario de prueba
            Usuario = self.db_config.Usuario
            user_test = Usuario.query.filter_by(id=self.test_user_id).first()
            if user_test:
                self.db_config.db.session.delete(user_test)
                print("‚úÖ Usuario de prueba eliminado")
            
            self.db_config.db.session.commit()
            print("‚úÖ Limpieza completada")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error en limpieza: {e}")
            self.db_config.db.session.rollback()
    
    def generate_database_report(self):
        """Generar reporte de validaci√≥n de BD"""
        print("\n" + "=" * 70)
        print("üìä REPORTE DE VALIDACI√ìN DE BASE DE DATOS")
        print("=" * 70)
        
        total_tests = len(self.test_results)
        passed_tests = sum(1 for result in self.test_results.values() if result)
        success_rate = (passed_tests / total_tests) * 100
        
        # Estado general
        if success_rate >= 90:
            status = "üü¢ EXCELENTE - BD COMPLETAMENTE FUNCIONAL"
        elif success_rate >= 75:
            status = "üü° BUENO - BD FUNCIONAL CON OBSERVACIONES"
        elif success_rate >= 60:
            status = "üü† ACEPTABLE - PROBLEMAS MENORES DE BD"
        else:
            status = "üî¥ CR√çTICO - BD NO FUNCIONAL"
        
        print(f"\nüéØ PUNTUACI√ìN BD: {success_rate:.1f}/100")
        print(f"üìà ESTADO: {status}")
        
        # Detalle por prueba
        print(f"\nüìã RESULTADOS DETALLADOS:")
        test_names = {
            "connection_test": "üîå Conexi√≥n a BD",
            "model_validation": "üìã Validaci√≥n de Modelos",
            "crud_operations": "üîÑ Operaciones CRUD",
            "availability_queries": "üìÖ Consultas de Disponibilidad",
            "reservation_flow": "üìù Flujo de Reserva",
            "data_persistence": "üíæ Persistencia de Datos",
            "transaction_integrity": "üîê Integridad de Transacciones"
        }
        
        for test_key, result in self.test_results.items():
            test_name = test_names.get(test_key, test_key)
            status = "‚úÖ PASS" if result else "‚ùå FAIL"
            print(f"   {test_name}: {status}")
        
        # Recomendaciones
        print(f"\nüí° RECOMENDACIONES:")
        
        if success_rate >= 85:
            print("   ‚úÖ Base de datos completamente operativa para producci√≥n")
            print("   ‚úÖ Implementar monitoreo de performance en producci√≥n")
        elif success_rate >= 70:
            print("   ‚ö†Ô∏è Corregir fallos espec√≠ficos antes de producci√≥n")
            print("   ‚ö†Ô∏è Probar exhaustivamente funcionalidades fallidas")
        else:
            print("   üö® Revisar configuraci√≥n completa de base de datos")
            print("   üö® Verificar variables de entorno y permisos")
        
        print(f"\nüìä ESTAD√çSTICAS:")
        print(f"   ‚úÖ Pruebas exitosas: {passed_tests}/{total_tests}")
        print(f"   üë§ Usuario de prueba: {self.test_user_id}")
        print(f"   üïí Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        print("=" * 70)
        
        return success_rate >= 75
    
    def run_complete_database_validation(self):
        """Ejecutar validaci√≥n completa de BD"""
        print(f"\nüöÄ INICIANDO VALIDACI√ìN COMPLETA DE BASE DE DATOS")
        print(f"üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        try:
            # Ejecutar todas las pruebas en orden
            self.test_database_connection()
            self.test_model_validation()
            self.test_crud_operations()
            self.test_availability_queries()
            self.test_reservation_flow()
            self.test_data_persistence()
            self.test_transaction_integrity()
            
            # Limpiar datos de prueba
            self.cleanup_test_data()
            
            # Generar reporte final
            success = self.generate_database_report()
            
            return success
            
        except Exception as e:
            print(f"‚ùå Error fatal en validaci√≥n: {e}")
            return False

def main():
    """Funci√≥n principal"""
    print("üóÑÔ∏è INICIANDO VALIDACI√ìN REAL DE BASE DE DATOS")
    print("üéØ Objetivo: Verificar conectividad y operaciones cr√≠ticas")
    
    # Verificar variable de entorno cr√≠tica
    if not os.getenv('DATABASE_URL'):
        print("\n‚ùå ERROR CR√çTICO: DATABASE_URL no configurada")
        print("üîß Configura la variable de entorno antes de continuar")
        return False
    
    # Ejecutar validaci√≥n
    validator = DatabaseValidationTest()
    success = validator.run_complete_database_validation()
    
    print(f"\n{'='*70}")
    print("üèÅ RESULTADO VALIDACI√ìN DE BASE DE DATOS")
    print(f"{'='*70}")
    
    if success:
        print("‚úÖ BASE DE DATOS COMPLETAMENTE VALIDADA")
        print("üöÄ Lista para uso en producci√≥n")
    else:
        print("‚ùå BASE DE DATOS NO VALIDADA")
        print("üîß Corregir problemas antes de producci√≥n")
    
    print(f"{'='*70}")
    
    return success

if __name__ == "__main__":
    main()